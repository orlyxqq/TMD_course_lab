'''
–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É: 
1) –í –∫–æ—Ç–æ—Ä–æ–π ùëÄ –∞–±–æ–Ω–µ–Ω—Ç–æ–≤, ùëÄ < ‚àû 
2) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –∏–º–µ–µ—Ç –±—É—Ñ–µ—Ä –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–Ω—ã, ùëè < ‚àû 
3) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –ø–µ—Ä–µ–¥–∞–µ—Ç –≤ –∫–∞–Ω–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–≤–æ–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (ùëù1,ùëù2,‚Ä¶,ùëùùëÄ) 
4) –ù–∞ –≤—Ö–æ–¥ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞ –ø–æ—Å—Ç—É–ø–∞–µ—Ç –ü—É–∞—Å—Å–æ–Ω–æ–≤—Å–∫–∏–π –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π —Å 
–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é (ùúÜ1,ùúÜ2,‚Ä¶,ùúÜùëÄ) 
–û–ø–∏—Å–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å–∏—Å—Ç–µ–º—ã —Å –ø–æ–º–æ—â—å—é –º–Ω–æ–≥–æ–º–µ—Ä–Ω–æ–π –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–≤ ùëÄ –∏ ùëè 
—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã (ùëè + 1)ùëÄ < 20. –ö–∞–∂–¥–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ ‚Äî —ç—Ç–æ –≤–µ–∫—Ç–æ—Ä 
–¥–ª–∏–Ω–Ω—ã ùëÄ, –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–µ–∫—Ç–æ—Ä–∞ —ç—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±—É—Ñ–µ—Ä–µ —É –∞–±–æ–Ω–µ–Ω—Ç–æ–≤. 
–ó–Ω–∞—á–µ–Ω–∏—è ùëÄ –∏ ùëè —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å —Å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –ø–µ—Ä–µ—Ö–æ–¥–Ω—ã—Ö 
–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –≤—Ä—É—á–Ω—É—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö ùëÄ –∏ ùëè. 

–ü—É—Ç–µ–º –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏ ùëÄ –∏ ùëè –ø–ø–æ–ª—É—á–∏—Ç—å 
–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç ùúÜ —Å–ª–µ–¥—É—é—â–∏—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫: 
1) ùëÅ  ‚Äì —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π
2) ùëë  ‚Äì —Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ 
'''


import numpy as np 
import math
from collections import deque
import tqdm


def create_transition_matrix(buffer_size, p, lambda_rate):
    size = (buffer_size + 1)
    transition_matrix = np.zeros((size, size))
    for i in range(size):
        for j in range(size):
            if i == 0:
                if j < buffer_size:
                    transition_matrix[i][j] = (lambda_rate ** j) * math.exp(-lambda_rate) / math.factorial(j)
                else:
                    transition_matrix[i][j] = 1 - sum(transition_matrix[i][:buffer_size])
            elif i == buffer_size:
                if j == buffer_size - 1:
                    transition_matrix[i][j] = 1.0
                else:
                    transition_matrix[i][j] = 0.0
            else:
                if j == size - 1:
                    transition_matrix[i][j] = 0
                elif j >= i - 1 and j == buffer_size - 1: #–ø–æ—Å–ª–µ–¥–Ω–∏–π –ø–µ—Ä–µ—Ö–æ–¥
                    transition_matrix[i][j] = 1 - sum(transition_matrix[i][:buffer_size])
                elif j >= i - 1 and j < buffer_size:
                    k = j - (i - 1)
                    transition_matrix[i][j] = (lambda_rate ** k) * math.exp(-lambda_rate) / math.factorial(k)
                else:
                    transition_matrix[i][j] = 0    
                
    return transition_matrix
        
    

def sim_metrics(arrival_rates, transmit_probs, buffer_size, time_windows):
    """
    arrival_rates   : list of floats (Œª_i) ‚Äî –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞
    transmit_probs  : list of floats (p_i) ‚Äî –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ –≤ –∫–∞–∂–¥–æ–º —Å–ª–æ—Ç–µ
    buffer_size     : int    ‚Äî —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞
    time_windows    : int    ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫–æ–Ω

    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç:
        svd[i] ‚Äî —Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–æ –∞–±–æ–Ω–µ–Ω—Ç—É i
        svr[i] ‚Äî —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ –∑–∞—è–≤–æ–∫ –≤ –æ—á–µ—Ä–µ–¥–∏
        dropped[i] ‚Äî –ø–æ—Ç–µ—Ä—è–Ω–Ω—ã–µ –ø–∞–∫–µ—Ç—ã
    """

    num_users = len(arrival_rates)

    # –û—á–µ—Ä–µ–¥–∏
    queues = [deque(maxlen=buffer_size) for _ in range(num_users)]

    # –ú–µ—Ç—Ä–∏–∫–∏
    processed = [0] * num_users
    dropped = [0] * num_users
    total_delay = [0.0] * num_users
    avg_queue_over_time = [[] for _ in range(num_users)]

    for current_window in tqdm.tqdm(range(time_windows), ncols=80, desc="Simulation"):

        window_start = current_window
        window_end = current_window + 1

        for i in range(num_users):
            n_arr = np.random.poisson(arrival_rates[i])
            if n_arr > 0:
                arr_times = np.random.uniform(window_start, window_end, n_arr)
                arr_times.sort()

                for t in arr_times:
                    if len(queues[i]) < buffer_size:
                        queues[i].append(t)
                    else:
                        dropped[i] += 1

            avg_queue_over_time[i].append(len(queues[i]))

        contenders = []   # –∞–±–æ–Ω–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—ã—Ç–∞—é—Ç—Å—è –ø–µ—Ä–µ–¥–∞—Ç—å

        for i in range(num_users):
            if queues[i] and np.random.rand() < transmit_probs[i]:
                contenders.append(i)

        if len(contenders) == 1:
            user = contenders[0]
            arrival_time = queues[user].popleft()

            delay = (window_end - arrival_time) + 1
            total_delay[user] += delay
            processed[user] += 1

    avg_delay = [
        total_delay[i] / processed[i] if processed[i] > 0 else 0.0
        for i in range(num_users)
    ]

    avg_queue = [
        sum(avg_queue_over_time[i]) / len(avg_queue_over_time[i])
        for i in range(num_users)
    ]

    return {
        'svd': avg_delay,
        'svr': avg_queue,
        'dropped': dropped
    }

def teor_metrics(): 
    pass

def plot_graphics():
    pass

def main():
    #(b + 1)^M < 20
    M = 2 #–∞–±–æ–Ω–µ–Ω—Ç—ã  
    b = 4 #–±—É—Ñ–µ—Ä
    
    lambda_rate_i = [0.3, 0.2]
    T = 10000 #—Ç–∞–π–º—Å–ª–æ—Ç—ã –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏
    P_i = [0.1, 0.9] #–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–±–æ–Ω–µ–Ω—Ç–∞–º–∏
    
    
    transition_matrix = create_transition_matrix(b, P_i[0], 0.2 )
    teor_metrics_abonents = sim_metrics(lambda_rate_i, P_i, b, T)
    
    print(teor_metrics_abonents)
    
    
    
if __name__ == "__main__":
    main()
    

