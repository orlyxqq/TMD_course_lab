'''
–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É: 
1) –í –∫–æ—Ç–æ—Ä–æ–π ùëÄ –∞–±–æ–Ω–µ–Ω—Ç–æ–≤, ùëÄ < ‚àû 
2) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –∏–º–µ–µ—Ç –±—É—Ñ–µ—Ä –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–Ω—ã, ùëè < ‚àû 
3) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –ø–µ—Ä–µ–¥–∞–µ—Ç –≤ –∫–∞–Ω–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–≤–æ–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (ùëù1,ùëù2,‚Ä¶,ùëùùëÄ) 
4) –ù–∞ –≤—Ö–æ–¥ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞ –ø–æ—Å—Ç—É–ø–∞–µ—Ç –ü—É–∞—Å—Å–æ–Ω–æ–≤—Å–∫–∏–π –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π —Å 
–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é (ùúÜ1,ùúÜ2,‚Ä¶,ùúÜùëÄ) 
–û–ø–∏—Å–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å–∏—Å—Ç–µ–º—ã —Å –ø–æ–º–æ—â—å—é –º–Ω–æ–≥–æ–º–µ—Ä–Ω–æ–π –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–≤ ùëÄ –∏ ùëè 
—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã (ùëè + 1)^ùëÄ < 20. –ö–∞–∂–¥–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ ‚Äî —ç—Ç–æ –≤–µ–∫—Ç–æ—Ä 
–¥–ª–∏–Ω–Ω—ã ùëÄ, –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–µ–∫—Ç–æ—Ä–∞ —ç—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±—É—Ñ–µ—Ä–µ —É –∞–±–æ–Ω–µ–Ω—Ç–æ–≤. 
–ó–Ω–∞—á–µ–Ω–∏—è ùëÄ –∏ ùëè —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å —Å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –ø–µ—Ä–µ—Ö–æ–¥–Ω—ã—Ö 
–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –≤—Ä—É—á–Ω—É—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö ùëÄ –∏ ùëè. 

–ü—É—Ç–µ–º –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏ ùëÄ –∏ ùëè –ø–ø–æ–ª—É—á–∏—Ç—å 
–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç ùúÜ —Å–ª–µ–¥—É—é—â–∏—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫: 
1) ùëÅ  ‚Äì —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π
2) ùëë  ‚Äì —Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ 
'''


import numpy as np 
from collections import deque
import itertools
import tqdm
import numpy as np
from itertools import product
import math
import matplotlib.pyplot as plt

def poisson_prob(k, lam):
    return math.exp(-lam) * lam**k / math.factorial(k)

def create_transition_matrix(arrival_rates, transmit_probs, buffer_size):
    
    num_users = len(arrival_rates)
    num_states = (buffer_size + 1) ** num_users

    all_states = list(product(range(buffer_size + 1), repeat=num_users))
    state_index = {s: i for i, s in enumerate(all_states)}

    P = np.zeros((num_states, num_states))

    for idx, state in enumerate(all_states):

        
        transmit_options = []
        for i in range(num_users):
            if state[i] > 0:
                transmit_options.append([(0, 1 - transmit_probs[i]), (1, transmit_probs[i])])
            else:
                transmit_options.append([(0, 1.0)]) 

        for transmit_combo in product(*transmit_options):
            
            contenders = [i for i, t in enumerate(transmit_combo) if t[0] == 1]
            
            p_tx = np.prod([t[1] for t in transmit_combo])

            if len(contenders) <= 1:
                transmitted = [0] * num_users
                if len(contenders) == 1:
                    transmitted[contenders[0]] = 1
            else:
                transmitted = [0] * num_users

            state_after_tx = tuple(max(state[i] - transmitted[i], 0) for i in range(num_users))

            arrivals_list = []
            for i, lam in enumerate(arrival_rates):
                max_arrival = buffer_size - state_after_tx[i]
                arrivals_prob = [poisson_prob(k, lam) for k in range(max_arrival + 1)]
                arrivals_prob[-1] = 1 - sum(arrivals_prob[:-1])
                arrivals_list.append(list(enumerate(arrivals_prob)))

            for arrivals_combo in product(*arrivals_list):
                next_state = tuple(min(state_after_tx[i] + arrivals_combo[i][0], buffer_size)
                                   for i in range(num_users))
                p_arr = np.prod([arrivals_combo[i][1] for i in range(num_users)])
                P[idx, state_index[next_state]] += p_tx * p_arr

    return P

def sim_metrics(arrival_rates, transmit_probs, buffer_size, time_windows):

    num_users = len(arrival_rates)

    queues = [deque(maxlen=buffer_size) for _ in range(num_users)]
    processed_requests = [0] * num_users
    total_delay = [0.0] * num_users
    avg_queue_over_time = [[] for _ in range(num_users)]

    for current_window in tqdm.tqdm(range(time_windows), ncols=80, desc="magic"):

        window_start = current_window
        window_end = window_start + 1

        contenders = []
        for u in range(num_users):
            if queues[u] and np.random.rand() < transmit_probs[u]:
                contenders.append(u)

        if len(contenders) == 1:
            u = contenders[0]
            arrival_time = queues[u].popleft()
            delay = (window_end - arrival_time) 
            total_delay[u] += delay
            processed_requests[u] += 1

        for u in range(num_users):
            n_arr = np.random.poisson(arrival_rates[u])
            if n_arr > 0:
                arr_times = np.random.uniform(window_start, window_end, n_arr)
                arr_times.sort()
                for t in arr_times:
                    if len(queues[u]) < buffer_size:
                        queues[u].append(t)

        for u in range(num_users):
            avg_queue_over_time[u].append(len(queues[u]))

    avg_delay = [
        total_delay[u] / processed_requests[u] if processed_requests[u] > 0 else 0.0
        for u in range(num_users)
    ]
    avg_queue = [
        sum(avg_queue_over_time[u]) / len(avg_queue_over_time[u])
        for u in range(num_users)
    ]
    lambd_out = [processed_requests[u] / time_windows for u in range(num_users)]

    return {
        'svd': avg_delay,
        'svr': avg_queue,
        'lambdout': lambd_out
    }
def teor_metrics(transition_matrix, arrival_rates, transmit_probs, buffer_size):

    P = np.asarray(transition_matrix)
    n = P.shape[0]

    A = P.T - np.eye(n)
    A[-1, :] = 1.0
    b = np.zeros(n)
    b[-1] = 1.0
    pi = np.linalg.solve(A, b)

    num_users = len(transmit_probs)
    all_states = list(product(range(buffer_size + 1), repeat=num_users))

    # 1. –°—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±—É—Ñ–µ—Ä–µ
    avg_queue = []
    for u in range(num_users):
        q_u = sum(pi[i] * all_states[i][u] for i in range(n))
        avg_queue.append(q_u)

    # 2. –í—ã—Ö–æ–¥–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å Œª_out (throughput)
    lambd_out = []
    for u in range(num_users):
        th_u = 0.0
        p_u = transmit_probs[u]
        for i, state in enumerate(all_states):

            if state[u] == 0:
                continue

            prob_others_not_tx = 1.0
            for j in range(num_users):
                if j == u:
                    continue
                if state[j] > 0:
                    prob_others_not_tx *= (1 - transmit_probs[j])

            success_prob = p_u * prob_others_not_tx
            th_u += pi[i] * success_prob


        lambd_out.append(th_u)

    # 3. –°—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ (Little‚Äôs law + 0.5)
    avg_delay = []
    for u in range(num_users):
        if lambd_out[u] > 0:
            avg_delay.append(avg_queue[u] / lambd_out[u] + 0.5)
        else:
            avg_delay.append(0.0)

    return {
        'tvd': avg_delay,          # –∑–∞–¥–µ—Ä–∂–∫–∞
        'tvr': avg_queue,          # —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π
        'lambdout': lambd_out     
    }


def main():
    #(b + 1)^M < 20
    
    M = 3 #–∞–±–æ–Ω–µ–Ω—Ç—ã  
    b = 2 #–±—É—Ñ–µ—Ä
    
    # lambda_rate_list = [0.7, 0.7, 0.7] #–≤—Ö–æ–¥–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å
    p_transmit_list = [1/2, 1/5, 1/5] #–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–±–æ–Ω–µ–Ω—Ç–∞–º–∏
    # time_windows = 100000 #—Ç–∞–π–º—Å–ª–æ—Ç—ã
    
    
    # sim_metrics_abonents = sim_metrics(lambda_rate_list, p_transmit_list, b, time_windows)
    # transition_matrix = create_transition_matrix(lambda_rate_list ,p_transmit_list, b)
    # teor_metrics_abonents = teor_metrics(transition_matrix, lambda_rate_list, p_transmit_list, b)
    
    # print(transition_matrix)
    # print(sim_metrics_abonents)
    # print(teor_metrics_abonents)
    
    lambda_values = np.linspace(0.1, 1.0, 10)

    sim_delay = [[] for _ in range(M)]
    teor_delay = [[] for _ in range(M)]
    sim_queue = [[] for _ in range(M)]
    teor_queue = [[] for _ in range(M)]
    sim_lambdas = [[] for _ in range(M)]
    teor_lambdas = [[] for _ in range(M)]

    time_windows = 20000 

    for lam in lambda_values:
        lambda_rate_list = [lam] * M
        lambda_rate_list[1] = 0.05
        lambda_rate_list[2] = 0.05
        print(lambda_rate_list)
        

        sim_res = sim_metrics(lambda_rate_list, p_transmit_list, b, time_windows)

        P = create_transition_matrix(lambda_rate_list, p_transmit_list, b)
        teor_res = teor_metrics(P, lambda_rate_list, p_transmit_list, b)

        for u in range(M):
            sim_delay[u].append(sim_res['svd'][u])
            teor_delay[u].append(teor_res['tvd'][u])
            sim_queue[u].append(sim_res['svr'][u])
            teor_queue[u].append(teor_res['tvr'][u])
            sim_lambdas[u].append(sim_res['lambdout'][u])
            teor_lambdas[u].append(teor_res['lambdout'][u])
    



    plt.figure(figsize=(7,5))
    for u in range(M):
        plt.plot(lambda_values, teor_delay[u], label=f"–¢–µ–æ—Ä–∏—è, –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
        plt.plot(lambda_values, sim_delay[u], '--', label=f"–°–∏–º—É–ª—è—Ü–∏—è, –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
    plt.title("–°—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞")
    plt.xlabel("Œª")
    plt.ylabel("—Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞")
    plt.grid(True)
    plt.legend()
    plt.show()

    plt.figure(figsize=(7,5))
    for u in range(M):
        plt.plot(lambda_values, teor_queue[u], label=f"–¢–µ–æ—Ä–∏—è, –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
        plt.plot(lambda_values, sim_queue[u], '--', label=f"–°–∏–º—É–ª—è—Ü–∏—è, –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
    plt.title("–°—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π")
    plt.xlabel("Œª")
    plt.ylabel("–°—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π")
    plt.grid(True)
    plt.legend()
    plt.show()
    
    plt.figure(figsize=(7,5))
    for u in range(M):
        plt.plot(lambda_values, teor_lambdas[u], label=f"–¢–µ–æ—Ä–∏—è Œª_out –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
        plt.plot(lambda_values, sim_lambdas[u], '--', label=f"–°–∏–º—É–ª—è—Ü–∏—è Œª_out –∞–±–æ–Ω–µ–Ω—Ç {u+1}")
    plt.title("–í—ã—Ö–æ–¥–Ω–∞—è –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å Œª_out")
    plt.xlabel("Œª_in")
    plt.ylabel("Œª_out")
    plt.grid(True)
    plt.legend()
    plt.show()

if __name__ == "__main__":
    main()
