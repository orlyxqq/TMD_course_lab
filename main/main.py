'''
–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É: 
1) –í –∫–æ—Ç–æ—Ä–æ–π ùëÄ –∞–±–æ–Ω–µ–Ω—Ç–æ–≤, ùëÄ < ‚àû 
2) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –∏–º–µ–µ—Ç –±—É—Ñ–µ—Ä –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–Ω—ã, ùëè < ‚àû 
3) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –ø–µ—Ä–µ–¥–∞–µ—Ç –≤ –∫–∞–Ω–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–≤–æ–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (ùëù1,ùëù2,‚Ä¶,ùëùùëÄ) 
4) –ù–∞ –≤—Ö–æ–¥ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞ –ø–æ—Å—Ç—É–ø–∞–µ—Ç –ü—É–∞—Å—Å–æ–Ω–æ–≤—Å–∫–∏–π –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π —Å 
–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é (ùúÜ1,ùúÜ2,‚Ä¶,ùúÜùëÄ) 
–û–ø–∏—Å–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å–∏—Å—Ç–µ–º—ã —Å –ø–æ–º–æ—â—å—é –º–Ω–æ–≥–æ–º–µ—Ä–Ω–æ–π –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–≤ ùëÄ –∏ ùëè 
—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã (ùëè + 1)ùëÄ < 20. –ö–∞–∂–¥–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ ‚Äî —ç—Ç–æ –≤–µ–∫—Ç–æ—Ä 
–¥–ª–∏–Ω–Ω—ã ùëÄ, –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–µ–∫—Ç–æ—Ä–∞ —ç—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±—É—Ñ–µ—Ä–µ —É –∞–±–æ–Ω–µ–Ω—Ç–æ–≤. 
–ó–Ω–∞—á–µ–Ω–∏—è ùëÄ –∏ ùëè —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å —Å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –ø–µ—Ä–µ—Ö–æ–¥–Ω—ã—Ö 
–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –≤—Ä—É—á–Ω—É—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö ùëÄ –∏ ùëè. 

–ü—É—Ç–µ–º –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏ ùëÄ –∏ ùëè –ø–ø–æ–ª—É—á–∏—Ç—å 
–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç ùúÜ —Å–ª–µ–¥—É—é—â–∏—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫: 
1) ùëÅ  ‚Äì —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π
2) ùëë  ‚Äì —Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ 
'''


import numpy as np 
from collections import deque
import itertools
import tqdm


def create_transition_matrix(M, B, lambda_rate, p):
    """
    –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞ –ø–µ—Ä–µ—Ö–æ–¥–æ–≤ –¥–ª—è M –∞–±–æ–Ω–µ–Ω—Ç–æ–≤ –∏ –±—É—Ñ–µ—Ä–∞ B.
    y[i] = exp(-lambda[i])
    p[i] ‚Äì –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —É—Å–ø–µ—Ö–∞ –ø–µ—Ä–µ–¥–∞—á–∏.
    """

    # --- –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è ---
    y = np.exp(-np.array(lambda_rate))

    # --- –≤—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è ---
    states = list(itertools.product(range(B + 1), repeat=M))
    S = len(states)
    index = {s: i for i, s in enumerate(states)}

    P = np.zeros((S, S))

    for s_idx, state in enumerate(states):

        for T in range(M):                     # –∫—Ç–æ –ø–µ—Ä–µ–¥–∞—ë—Ç
            for success in [0, 1]:             # —É—Å–ø–µ—Ö –ø–µ—Ä–µ–¥–∞—á–∏
                for arrivals in itertools.product([0, 1], repeat=M):

                    # --- –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Å–æ–±—ã—Ç–∏—è ---
                    prob = 1.0

                    # –≤—ã–±–æ—Ä –ø–µ—Ä–µ–¥–∞—é—â–µ–≥–æ
                    prob *= 1.0 / M

                    # —É—Å–ø–µ—Ö/–Ω–µ—É–¥–∞—á–∞ –ø–µ—Ä–µ–¥–∞—á–∏
                    prob *= p[T] if success else (1 - p[T])

                    # –ø—Ä–∏—Ö–æ–¥—ã —Å–æ–æ–±—â–µ–Ω–∏–π
                    for i in range(M):
                        prob *= y[i] if arrivals[i] else (1 - y[i])

                    if prob == 0:
                        continue

                    # --- —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–ª–µ–¥—É—é—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ---
                    new_state = list(state)

                    for i in range(M):

                        # —É—Ö–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è
                        if i == T and state[i] > 0 and success:
                            new_state[i] -= 1

                        # –ø—Ä–∏—Ö–æ–¥ —Å–æ–æ–±—â–µ–Ω–∏—è
                        if arrivals[i] == 1 and new_state[i] < B:
                            new_state[i] += 1

                    new_state = tuple(new_state)
                    new_idx = index[new_state]

                    P[s_idx, new_idx] += prob

    return P
    

def sim_metrics(arrival_rates, transmit_probs, buffer_size, time_windows):

    num_users = len(arrival_rates)

    # –û—á–µ—Ä–µ–¥–∏
    queues = [deque(maxlen=buffer_size) for _ in range(num_users)]

    processed = [0] * num_users
    dropped = [0] * num_users
    total_delay = [0.0] * num_users
    avg_queue_over_time = [[] for _ in range(num_users)]

    for current_window in tqdm.tqdm(range(time_windows), ncols=80, desc="Simulation"):

        window_start = current_window
        window_end = current_window + 1

        for i in range(num_users):
            n_arr = np.random.poisson(arrival_rates[i])
            if n_arr > 0:
                arr_times = np.random.uniform(window_start, window_end, n_arr)
                arr_times.sort()

                for t in arr_times:
                    if len(queues[i]) < buffer_size:
                        queues[i].append(t)
                    else:
                        dropped[i] += 1

            avg_queue_over_time[i].append(len(queues[i]))

        contenders = []   # –∞–±–æ–Ω–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—ã—Ç–∞—é—Ç—Å—è –ø–µ—Ä–µ–¥–∞—Ç—å

        for i in range(num_users):
            if queues[i] and np.random.rand() < transmit_probs[i]:
                contenders.append(i)

        if len(contenders) == 1:
            user = contenders[0]
            arrival_time = queues[user].popleft()

            delay = (window_end - arrival_time) + 1
            total_delay[user] += delay
            processed[user] += 1

    avg_delay = [
        total_delay[i] / processed[i] if processed[i] > 0 else 0.0
        for i in range(num_users)
    ]

    avg_queue = [
        sum(avg_queue_over_time[i]) / len(avg_queue_over_time[i])
        for i in range(num_users)
    ]

    return {
        'svd': avg_delay,
        'svr': avg_queue,
        'dropped': dropped
    }

def teor_metrics(): 
    pass

def plot_graphics():
    pass

def main():
    #(b + 1)^M < 20
    
    M = 2 #–∞–±–æ–Ω–µ–Ω—Ç—ã  
    b = 1 #–±—É—Ñ–µ—Ä
    
    lambda_rate_list = [1.0, 1.0]
    p_transmit_list = [1.0, 1.0] #–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–±–æ–Ω–µ–Ω—Ç–∞–º–∏
    time_windows = 10000 #—Ç–∞–π–º—Å–ª–æ—Ç—ã –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏
    
    
    teor_metrics_abonents = sim_metrics(lambda_rate_list, p_transmit_list, b, time_windows)
    transition_matrix = create_transition_matrix(M, b, lambda_rate_list ,p_transmit_list)
    print(transition_matrix)
    #print(teor_metrics_abonents)
    
    
    
if __name__ == "__main__":
    main()
    
    
 
  
    

