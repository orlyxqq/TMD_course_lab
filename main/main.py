'''
–°–º–æ–¥–µ–ª–∏—Ä–æ–≤–∞—Ç—å —Å–∏—Å—Ç–µ–º—É: 
1) –í –∫–æ—Ç–æ—Ä–æ–π ùëÄ –∞–±–æ–Ω–µ–Ω—Ç–æ–≤, ùëÄ < ‚àû 
2) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –∏–º–µ–µ—Ç –±—É—Ñ–µ—Ä –æ–¥–∏–Ω–∞–∫–æ–≤–æ–π –¥–ª–∏–Ω–Ω—ã, ùëè < ‚àû 
3) –ö–∞–∂–¥—ã–π –∞–±–æ–Ω–µ–Ω—Ç –ø–µ—Ä–µ–¥–∞–µ—Ç –≤ –∫–∞–Ω–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–≤–æ–µ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é (ùëù1,ùëù2,‚Ä¶,ùëùùëÄ) 
4) –ù–∞ –≤—Ö–æ–¥ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞ –ø–æ—Å—Ç—É–ø–∞–µ—Ç –ü—É–∞—Å—Å–æ–Ω–æ–≤—Å–∫–∏–π –≤—Ö–æ–¥–Ω–æ–π –ø–æ—Ç–æ–∫ —Å–æ–æ–±—â–µ–Ω–∏–π —Å 
–∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç—å—é (ùúÜ1,ùúÜ2,‚Ä¶,ùúÜùëÄ) 
–û–ø–∏—Å–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å–∏—Å—Ç–µ–º—ã —Å –ø–æ–º–æ—â—å—é –º–Ω–æ–≥–æ–º–µ—Ä–Ω–æ–π –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–≤ ùëÄ –∏ ùëè 
—Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ–±—ã (ùëè + 1)ùëÄ < 20. –ö–∞–∂–¥–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ú–∞—Ä–∫–æ–≤—Å–∫–æ–π —Ü–µ–ø–∏ ‚Äî —ç—Ç–æ –≤–µ–∫—Ç–æ—Ä 
–¥–ª–∏–Ω–Ω—ã ùëÄ, –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≤–µ–∫—Ç–æ—Ä–∞ —ç—Ç–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–æ–æ–±—â–µ–Ω–∏–π –≤ –±—É—Ñ–µ—Ä–µ —É –∞–±–æ–Ω–µ–Ω—Ç–æ–≤. 
–ó–Ω–∞—á–µ–Ω–∏—è ùëÄ –∏ ùëè —Å–æ–≥–ª–∞—Å–æ–≤–∞—Ç—å —Å –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª–µ–º. –°—Ñ–æ—Ä–º–∏—Ä–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –ø–µ—Ä–µ—Ö–æ–¥–Ω—ã—Ö 
–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π –≤—Ä—É—á–Ω—É—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö ùëÄ –∏ ùëè. 

–ü—É—Ç–µ–º –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞—Å—á–µ—Ç–∞ –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º –∑–Ω–∞—á–µ–Ω–∏–∏ ùëÄ –∏ ùëè –ø–ø–æ–ª—É—á–∏—Ç—å 
–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç ùúÜ —Å–ª–µ–¥—É—é—â–∏—Ö —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫: 
1) ùëÅ  ‚Äì —Å—Ä–µ–¥–Ω–µ–µ —á–∏—Å–ª–æ —Å–æ–æ–±—â–µ–Ω–∏–π
2) ùëë  ‚Äì —Å—Ä–µ–¥–Ω—è—è –∑–∞–¥–µ—Ä–∂–∫–∞ 
'''


import numpy as np 
import math
from collections import deque
import tqdm
from scipy.stats import poisson
from itertools import product


def state_to_index(state, b):
    """–ü–µ—Ä–µ–≤–æ–¥ —Å–æ—Å—Ç–æ—è–Ω–∏—è (n1,...,nM) –≤ –∏–Ω–¥–µ–∫—Å"""
    M = len(state)
    index = 0
    for i, n in enumerate(state):
        index += n * (b+1)**(M-1-i)
    return index

def index_to_state(index, M, b):
    """–ü–µ—Ä–µ–≤–æ–¥ –∏–Ω–¥–µ–∫—Å–∞ –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–µ"""
    state = []
    for i in range(M):
        div = (b+1)**(M-1-i)
        n = index // div
        state.append(n)
        index %= div
    return tuple(state)

def create_transition_matrix(lambda_rates, p_transmit_list, b):
    """
    –°–æ–∑–¥–∞–Ω–∏–µ –º–∞—Ç—Ä–∏—Ü—ã –ø–µ—Ä–µ—Ö–æ–¥–æ–≤ –¥–ª—è M –∞–±–æ–Ω–µ–Ω—Ç–æ–≤
    lambda_rates: list[float] Œª_i
    p_transmit_list: list[float] p_i
    b: int, —Ä–∞–∑–º–µ—Ä –±—É—Ñ–µ—Ä–∞ –∫–∞–∂–¥–æ–≥–æ –∞–±–æ–Ω–µ–Ω—Ç–∞
    """
    M = len(lambda_rates)
    size = (b+1)**M
    P = np.zeros((size, size))

    # –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–∏—Å—Ç–µ–º—ã
    for state in product(range(b+1), repeat=M):
        idx_from = state_to_index(state, b)

        # --- –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∫–æ–º–±–∏–Ω–∞—Ü–∏–π –ø—Ä–∏–±—ã–≤—à–∏—Ö –ø–∞–∫–µ—Ç–æ–≤ ---
        # –ë–µ—Ä–µ–º –¥–æ b –ø–∞–∫–µ—Ç–æ–≤, –º–æ–∂–Ω–æ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º
        arrival_ranges = [range(b+1) for _ in range(M)]

        for arrivals in product(*arrival_ranges):
            prob_arrival = 1.0
            next_state = list(state)

            for i in range(M):
                # Poisson –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å k –ø–∞–∫–µ—Ç–æ–≤
                k = arrivals[i]
                if state[i] + k > b:
                    k = b - state[i]  # –æ–±—Ä–µ–∑–∫–∞ –±—É—Ñ–µ—Ä–∞
                prob_arrival *= poisson.pmf(k, lambda_rates[i])
                next_state[i] = state[i] + k

            # --- –í—ã–±–æ—Ä –∞–±–æ–Ω–µ–Ω—Ç–∞ –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –ø–∞–∫–µ—Ç–∞ ---
            contenders = [i for i in range(M) if state[i] > 0]

            success_probs = []

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –≤—Å–µ –∫–æ–º–±–∏–Ω–∞—Ü–∏–∏ –ø–æ–ø—ã—Ç–æ–∫ –ø–µ—Ä–µ–¥–∞—á–∏
            # –ö–∞–∂–¥–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è ‚Äî –±–∏–Ω–∞—Ä–Ω—ã–π –≤–µ–∫—Ç–æ—Ä –¥–ª–∏–Ω—ã M
            # prob_attempt[i] = p_i –µ—Å–ª–∏ –ø–∞–∫–µ—Ç –µ—Å—Ç—å, –∏–Ω–∞—á–µ 0
            attempts_probs = []
            for i in range(M):
                if state[i] > 0:
                    attempts_probs.append([1 - p_transmit_list[i], p_transmit_list[i]])
                else:
                    attempts_probs.append([1.0, 0.0])

            for attempt in product(*attempts_probs):
                # –ö—Ç–æ –ø—ã—Ç–∞–µ—Ç—Å—è –ø–µ—Ä–µ–¥–∞—Ç—å
                num_attempts = sum(attempt)
                next_state_final = next_state.copy()
                prob_attempt_comb = np.prod([ap for ap in attempt])
                if num_attempts == 1:
                    # —É—Å–ø–µ—à–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ ‚Üí —É–º–µ–Ω—å—à–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –±—É—Ñ–µ—Ä
                    idx_success = attempt.index(1)
                    next_state_final[idx_success] = max(0, next_state_final[idx_success] - 1)
                # –∏–Ω–∞—á–µ –∫–æ–ª–ª–∏–∑–∏—è ‚Üí –Ω–∏–∫—Ç–æ –Ω–µ –ø–µ—Ä–µ–¥–∞–µ—Ç

                idx_to = state_to_index(next_state_final, b)
                P[idx_from, idx_to] += prob_arrival * prob_attempt_comb

    return P
        
    

def sim_metrics(arrival_rates, transmit_probs, buffer_size, time_windows):

    num_users = len(arrival_rates)

    # –û—á–µ—Ä–µ–¥–∏
    queues = [deque(maxlen=buffer_size) for _ in range(num_users)]

    processed = [0] * num_users
    dropped = [0] * num_users
    total_delay = [0.0] * num_users
    avg_queue_over_time = [[] for _ in range(num_users)]

    for current_window in tqdm.tqdm(range(time_windows), ncols=80, desc="Simulation"):

        window_start = current_window
        window_end = current_window + 1

        for i in range(num_users):
            n_arr = np.random.poisson(arrival_rates[i])
            if n_arr > 0:
                arr_times = np.random.uniform(window_start, window_end, n_arr)
                arr_times.sort()

                for t in arr_times:
                    if len(queues[i]) < buffer_size:
                        queues[i].append(t)
                    else:
                        dropped[i] += 1

            avg_queue_over_time[i].append(len(queues[i]))

        contenders = []   # –∞–±–æ–Ω–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø—ã—Ç–∞—é—Ç—Å—è –ø–µ—Ä–µ–¥–∞—Ç—å

        for i in range(num_users):
            if queues[i] and np.random.rand() < transmit_probs[i]:
                contenders.append(i)

        if len(contenders) == 1:
            user = contenders[0]
            arrival_time = queues[user].popleft()

            delay = (window_end - arrival_time) + 1
            total_delay[user] += delay
            processed[user] += 1

    avg_delay = [
        total_delay[i] / processed[i] if processed[i] > 0 else 0.0
        for i in range(num_users)
    ]

    avg_queue = [
        sum(avg_queue_over_time[i]) / len(avg_queue_over_time[i])
        for i in range(num_users)
    ]

    return {
        'svd': avg_delay,
        'svr': avg_queue,
        'dropped': dropped
    }

def teor_metrics(): 
    pass

def plot_graphics():
    pass

def main():
    #(b + 1)^M < 20
    M = 2 #–∞–±–æ–Ω–µ–Ω—Ç—ã  
    b = 1 #–±—É—Ñ–µ—Ä
    
    lambda_rate_i = [0.3, 0.2]
    P_i = [0.1, 0.9] #–≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –ø–µ—Ä–µ–¥–∞—á–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –∞–±–æ–Ω–µ–Ω—Ç–∞–º–∏
    
    T = 10000 #—Ç–∞–π–º—Å–ª–æ—Ç—ã –¥–ª—è —Å–∏–º—É–ª—è—Ü–∏
    
    
    
    teor_metrics_abonents = sim_metrics(lambda_rate_i, P_i, b, T)
    teor_matrix = create_transition_matrix(lambda_rate_i, P_i, b)
    print(teor_matrix)
    #print(teor_metrics_abonents)
    
    
    
if __name__ == "__main__":
    main()
    
    
 
  
    

